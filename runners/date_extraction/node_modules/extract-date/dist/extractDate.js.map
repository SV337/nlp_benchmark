{"version":3,"sources":["../src/extractDate.js"],"names":["log","Logger","child","namespace","defaultConfiguration","maximumAge","Infinity","minimumAge","formats","dateFnsLocaleMap","en","input","userConfiguration","debug","normalizedInput","configuration","locale","dateFnsLocale","locales","Error","dictionary","timezone","moment","tz","zone","words","split","matches","baseDate","Date","format","movingChunks","wordCount","chunkIndex","movingChunk","wordOffset","subject","join","dateFnsFormat","trace","maybeDate","slice","direction","push","date","yearIsExplicit","formatDirection","configurationDirection","includes","replace","info","currentYear","parseInt","currentMonth","parsedMonth","difference","useYear","Math","abs"],"mappings":";;;;;;;AAIA;;AAKA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;;;;;;;AAdA;AAqBA,MAAMA,GAAG,GAAGC,gBAAOC,KAAP,CAAa;AACvBC,EAAAA,SAAS,EAAE;AADY,CAAb,CAAZ;;AAIA,MAAMC,oBAAoB,GAAG;AAC3BC,EAAAA,UAAU,EAAEC,QADe;AAE3BC,EAAAA,UAAU,EAAED;AAFe,CAA7B;AAKA,MAAME,OAAO,GAAG,6BAAhB;AAEA,MAAMC,gBAAgB,GAAG;AACvBC,EAAAA,EAAE,EAAE;AADmB,CAAzB,C,CAIA;;eACe,CAACC,KAAD,EAAgBC,iBAAwC,GAAGR,oBAA3D,KAAmH;AAChIJ,EAAAA,GAAG,CAACa,KAAJ,CAAU,4CAAV,EAAwDF,KAAxD;AAEA,QAAMG,eAAe,GAAG,6BAAeH,KAAf,CAAxB;AAEAX,EAAAA,GAAG,CAACa,KAAJ,CAAU,0BAAV,EAAsCC,eAAtC;AAEA,QAAMC,aAAgC,GAAG,EACvC,GAAGX,oBADoC;AAEvC,OAAGQ;AAFoC,GAAzC;AAKA,QAAMI,MAAM,GAAGD,aAAa,CAACC,MAAd,IAAwB,IAAvC;AAEA,QAAMC,aAAa,GAAGC,OAAO,CAACT,gBAAgB,CAACO,MAAD,CAAhB,IAA4BA,MAA7B,CAA7B;;AAEA,MAAI,CAACC,aAAL,EAAoB;AAClB,UAAM,IAAIE,KAAJ,CAAU,4DAAV,CAAN;AACD;;AAED,MAAI,CAACC,2BAAWJ,MAAX,CAAL,EAAyB;AACvB,UAAM,IAAIG,KAAJ,CAAU,kEAAV,CAAN;AACD;;AAED,MAAIJ,aAAa,CAACM,QAAd,IAA0B,CAACC,wBAAOC,EAAP,CAAUC,IAAV,CAAeT,aAAa,CAACM,QAA7B,CAA/B,EAAuE;AACrE,UAAM,IAAIF,KAAJ,CAAU,wBAAV,CAAN;AACD;;AAED,MAAIJ,aAAa,CAACV,UAAd,IAA4BU,aAAa,CAACV,UAAd,GAA2B,CAA3D,EAA8D;AAC5D,UAAM,IAAIc,KAAJ,CAAU,yCAAV,CAAN;AACD;;AAED,MAAIJ,aAAa,CAACR,UAAd,IAA4BQ,aAAa,CAACR,UAAd,GAA2B,CAA3D,EAA8D;AAC5D,UAAM,IAAIY,KAAJ,CAAU,yCAAV,CAAN;AACD;;AAEDnB,EAAAA,GAAG,CAACa,KAAJ,CAAU;AACRE,IAAAA;AADQ,GAAV,EAEG,4CAFH,EAEiDD,eAFjD;AAIA,MAAIW,KAAK,GAAGX,eAAe,CAACY,KAAhB,CAAsB,GAAtB,CAAZ;AAEA,QAAMC,OAAO,GAAG,EAAhB;AAEA,QAAMC,QAAQ,GAAG,oBAAU,OAAV,EAAmB,OAAnB,EAA4B,IAAIC,IAAJ,EAA5B,CAAjB;;AAEA,OAAK,MAAMC,MAAX,IAAqBtB,OAArB,EAA8B;AAC5B,UAAMuB,YAAY,GAAG,iCAAmBN,KAAnB,EAA0BK,MAAM,CAACE,SAAjC,CAArB;AAEA,QAAIC,UAAU,GAAG,CAAjB;;AAEA,SAAK,MAAMC,WAAX,IAA0BH,YAA1B,EAAwC;AACtC,YAAMI,UAAU,GAAG,EAAEF,UAAF,GAAeH,MAAM,CAACE,SAAzC;AAEA,YAAMI,OAAO,GAAGF,WAAW,CAACG,IAAZ,CAAiB,GAAjB,CAAhB;;AAEA,UAAIP,MAAM,CAACQ,aAAP,KAAyB,GAA7B,EAAkC;AAChC,YAAI,CAACvB,aAAa,CAACC,MAAnB,EAA2B;AACzBhB,UAAAA,GAAG,CAACuC,KAAJ,CAAU,sDAAV;AACD,SAFD,MAEO,IAAI,CAACxB,aAAa,CAACM,QAAnB,EAA6B;AAClCrB,UAAAA,GAAG,CAACuC,KAAJ,CAAU,wDAAV;AACD,SAFM,MAEA;AACL,gBAAMC,SAAS,GAAG,kCAAoBJ,OAApB,EAA6BrB,aAAa,CAACC,MAA3C,EAAmDD,aAAa,CAACM,QAAjE,CAAlB;;AAEA,cAAImB,SAAJ,EAAe;AACbf,YAAAA,KAAK,GAAGA,KAAK,CAACgB,KAAN,CAAYN,UAAZ,CAAR;AAEAnC,YAAAA,GAAG,CAACa,KAAJ,CAAU,qDAAV,EAAiEuB,OAAjE,EAA0EN,MAAM,CAACQ,aAAjF,EAAgGR,MAAM,CAACY,SAAP,IAAoB,IAApH;AAEAf,YAAAA,OAAO,CAACgB,IAAR,CAAa;AACXC,cAAAA,IAAI,EAAEJ;AADK,aAAb;AAGD;AACF;AACF,OAlBD,MAkBO,IAAIV,MAAM,CAACQ,aAAP,KAAyB,KAAzB,IAAkCR,MAAM,CAACQ,aAAP,KAAyB,MAA/D,EAAuE;AAC5E,cAAMM,IAAI,GAAG,oBACXR,OADW,EAEXN,MAAM,CAACQ,aAFI,EAGXV,QAHW,EAIX;AACEZ,UAAAA,MAAM,EAAEC;AADV,SAJW,CAAb;;AASA,YAAI,sBAAY2B,IAAZ,CAAJ,EAAuB;AACrBnB,UAAAA,KAAK,GAAGA,KAAK,CAACgB,KAAN,CAAYN,UAAZ,CAAR;AAEAnC,UAAAA,GAAG,CAACa,KAAJ,CAAU,qDAAV,EAAiEuB,OAAjE,EAA0EN,MAAM,CAACQ,aAAjF,EAAgGR,MAAM,CAACY,SAAP,IAAoB,IAApH;AAEAf,UAAAA,OAAO,CAACgB,IAAR,CAAa;AACXC,YAAAA,IAAI,EAAE,qBAAWA,IAAX,EAAiB,YAAjB;AADK,WAAb;AAGD;AACF,OAnBM,MAmBA;AACL,cAAMC,cAAc,GAAG,OAAOf,MAAM,CAACe,cAAd,KAAiC,SAAjC,GAA6Cf,MAAM,CAACe,cAApD,GAAqE,IAA5F;;AAEA,YAAIA,cAAJ,EAAoB;AAClB,gBAAMD,IAAI,GAAG,oBACXR,OADW,EAEXN,MAAM,CAACQ,aAFI,EAGXV,QAHW,EAIX;AACEZ,YAAAA,MAAM,EAAEC;AADV,WAJW,CAAb;;AASA,cAAI,CAAC,sBAAY2B,IAAZ,CAAL,EAAwB;AACtB;AACD;;AAED,gBAAME,eAAe,GAAGhB,MAAM,CAACY,SAA/B;AACA,gBAAMK,sBAAsB,GAAGhC,aAAa,CAAC2B,SAA7C;;AAEA,cAAII,eAAe,IAAIC,sBAAnB,IAA6CjB,MAAM,CAACQ,aAAP,CAAqBU,QAArB,CAA8B,MAA9B,CAA7C,IAAsFF,eAAe,CAACG,OAAhB,CAAwB,GAAxB,EAA6B,EAA7B,MAAqCF,sBAAsB,CAACE,OAAvB,CAA+B,GAA/B,EAAoC,EAApC,CAA/H,EAAwK;AACtKjD,YAAAA,GAAG,CAACa,KAAJ,CAAU,wDAAV;AACD,WAFD,MAEO,IAAIiB,MAAM,CAACY,SAAP,IAAoBZ,MAAM,CAACY,SAAP,KAAqB3B,aAAa,CAAC2B,SAA3D,EAAsE;AAC3E1C,YAAAA,GAAG,CAACuC,KAAJ,CAAU,sCAAV;AAEA;AACD;;AAED,cAAIT,MAAM,CAACY,SAAP,IAAoB,CAAC3B,aAAa,CAAC2B,SAAvC,EAAkD;AAChD1C,YAAAA,GAAG,CAACkD,IAAJ,CAAS,kFAAT,EAA6FpB,MAAM,CAACQ,aAApG;AAEA;AACD;;AAEDb,UAAAA,KAAK,GAAGA,KAAK,CAACgB,KAAN,CAAYN,UAAZ,CAAR;AAEAnC,UAAAA,GAAG,CAACa,KAAJ,CAAU,qDAAV,EAAiEuB,OAAjE,EAA0EN,MAAM,CAACQ,aAAjF,EAAgGR,MAAM,CAACY,SAAP,IAAoB,IAApH;AAEAf,UAAAA,OAAO,CAACgB,IAAR,CAAa;AACXC,YAAAA,IAAI,EAAE,qBAAWA,IAAX,EAAiB,YAAjB;AADK,WAAb;AAGD,SAtCD,MAsCO;AACL,gBAAMA,IAAI,GAAG,oBACXR,OADW,EAEXN,MAAM,CAACQ,aAFI,EAGXV,QAHW,EAIX;AACEZ,YAAAA,MAAM,EAAEC;AADV,WAJW,CAAb;;AASA,cAAI,CAAC,sBAAY2B,IAAZ,CAAL,EAAwB;AACtB;AACD;;AAED,gBAAMO,WAAW,GAAGC,QAAQ,CAAC,qBAAWxB,QAAX,EAAqB,MAArB,CAAD,EAA+B,EAA/B,CAA5B;AAEA,gBAAMyB,YAAY,GAAGD,QAAQ,CAAC,qBAAWxB,QAAX,EAAqB,GAArB,CAAD,EAA4B,EAA5B,CAAR,GAA0CuB,WAAW,GAAG,EAA7E;AACA,gBAAMG,WAAW,GAAGF,QAAQ,CAAC,qBAAWR,IAAX,EAAiB,GAAjB,CAAD,EAAwB,EAAxB,CAAR,GAAsCQ,QAAQ,CAAC,qBAAWR,IAAX,EAAiB,MAAjB,CAAD,EAA2B,EAA3B,CAAR,GAAyC,EAAnG;AACA,gBAAMW,UAAU,GAAGD,WAAW,GAAGD,YAAjC;AAEA,cAAIG,OAAJ;;AAEA,cAAID,UAAU,IAAIxC,aAAa,CAACV,UAAhC,EAA4C;AAC1CmD,YAAAA,OAAO,GAAGL,WAAW,GAAG,CAAxB;AACD,WAFD,MAEO,IAAII,UAAU,GAAG,CAAb,IAAkBE,IAAI,CAACC,GAAL,CAASH,UAAT,KAAwBxC,aAAa,CAACR,UAA5D,EAAwE;AAC7EiD,YAAAA,OAAO,GAAGL,WAAW,GAAG,CAAxB;AACD,WAFM,MAEA;AACLK,YAAAA,OAAO,GAAGL,WAAV;AACD;;AAED,gBAAMX,SAAS,GAAG,oBAChBgB,OAAO,GAAG,GAAV,GAAgB,qBAAWZ,IAAX,EAAiB,OAAjB,CADA,EAEhB,YAFgB,EAGhBhB,QAHgB,EAIhB;AACEZ,YAAAA,MAAM,EAAEC;AADV,WAJgB,CAAlB;;AASA,cAAI,CAAC,sBAAYuB,SAAZ,CAAL,EAA6B;AAC3B;AACD;;AAED,cAAIV,MAAM,CAACY,SAAP,IAAoBZ,MAAM,CAACY,SAAP,KAAqB3B,aAAa,CAAC2B,SAA3D,EAAsE;AACpE1C,YAAAA,GAAG,CAACuC,KAAJ,CAAU,sCAAV;AAEA;AACD;;AAED,cAAIT,MAAM,CAACY,SAAP,IAAoB,CAAC3B,aAAa,CAAC2B,SAAvC,EAAkD;AAChD1C,YAAAA,GAAG,CAACkD,IAAJ,CAAS,+EAAT,EAA0FpB,MAAM,CAACQ,aAAjG;AAEA;AACD;;AAEDb,UAAAA,KAAK,GAAGA,KAAK,CAACgB,KAAN,CAAYN,UAAZ,CAAR;AAEAnC,UAAAA,GAAG,CAACa,KAAJ,CAAU,qDAAV,EAAiEuB,OAAjE,EAA0EN,MAAM,CAACQ,aAAjF,EAAgGR,MAAM,CAACY,SAAP,IAAoB,IAApH;AAEAf,UAAAA,OAAO,CAACgB,IAAR,CAAa;AACXC,YAAAA,IAAI,EAAE,qBAAWJ,SAAX,EAAsB,YAAtB;AADK,WAAb;AAGD;AACF;AACF;AACF;;AAED,SAAOb,OAAP;AACD,C","sourcesContent":["// @flow\n\n/* eslint-disable no-continue, no-negated-condition, import/no-namespace */\n\nimport {\n  format as formatDate,\n  parse as parseDate,\n  isValid as isValidDate,\n} from 'date-fns';\nimport * as locales from 'date-fns/locale';\nimport moment from 'moment-timezone';\nimport dictionary from 'relative-date-names';\nimport createMovingChunks from './createMovingChunks';\nimport extractRelativeDate from './extractRelativeDate';\nimport createFormats from './createFormats';\nimport normalizeInput from './normalizeInput';\nimport Logger from './Logger';\nimport type {\n  ConfigurationType,\n  DateMatchType,\n  UserConfigurationType,\n} from './types';\n\nconst log = Logger.child({\n  namespace: 'extractDate',\n});\n\nconst defaultConfiguration = {\n  maximumAge: Infinity,\n  minimumAge: Infinity,\n};\n\nconst formats = createFormats();\n\nconst dateFnsLocaleMap = {\n  en: 'enUS',\n};\n\n// eslint-disable-next-line complexity\nexport default (input: string, userConfiguration: UserConfigurationType = defaultConfiguration): $ReadOnlyArray<DateMatchType> => {\n  log.debug('attempting to extract date from \"%s\" input', input);\n\n  const normalizedInput = normalizeInput(input);\n\n  log.debug('normalized input to \"%s\"', normalizedInput);\n\n  const configuration: ConfigurationType = {\n    ...defaultConfiguration,\n    ...userConfiguration,\n  };\n\n  const locale = configuration.locale || 'en';\n\n  const dateFnsLocale = locales[dateFnsLocaleMap[locale] || locale];\n\n  if (!dateFnsLocale) {\n    throw new Error('No translation available for the target locale (date-fns).');\n  }\n\n  if (!dictionary[locale]) {\n    throw new Error('No translation available for the target locale (relative dates).');\n  }\n\n  if (configuration.timezone && !moment.tz.zone(configuration.timezone)) {\n    throw new Error('Unrecognized timezone.');\n  }\n\n  if (configuration.maximumAge && configuration.maximumAge < 0) {\n    throw new Error('`maximumAge` must be a positive number.');\n  }\n\n  if (configuration.minimumAge && configuration.minimumAge < 0) {\n    throw new Error('`minimumAge` must be a positive number.');\n  }\n\n  log.debug({\n    configuration,\n  }, 'attempting to extract date from \"%s\" input', normalizedInput);\n\n  let words = normalizedInput.split(' ');\n\n  const matches = [];\n\n  const baseDate = parseDate('12:00', 'HH:mm', new Date());\n\n  for (const format of formats) {\n    const movingChunks = createMovingChunks(words, format.wordCount);\n\n    let chunkIndex = 0;\n\n    for (const movingChunk of movingChunks) {\n      const wordOffset = ++chunkIndex * format.wordCount;\n\n      const subject = movingChunk.join(' ');\n\n      if (format.dateFnsFormat === 'R') {\n        if (!configuration.locale) {\n          log.trace('cannot attempt format without `locale` configuration');\n        } else if (!configuration.timezone) {\n          log.trace('cannot attempt format without `timezone` configuration');\n        } else {\n          const maybeDate = extractRelativeDate(subject, configuration.locale, configuration.timezone);\n\n          if (maybeDate) {\n            words = words.slice(wordOffset);\n\n            log.debug('matched \"%s\" input using \"%s\" format (%s direction)', subject, format.dateFnsFormat, format.direction || 'no');\n\n            matches.push({\n              date: maybeDate,\n            });\n          }\n        }\n      } else if (format.dateFnsFormat === 'EEE' || format.dateFnsFormat === 'EEEE') {\n        const date = parseDate(\n          subject,\n          format.dateFnsFormat,\n          baseDate,\n          {\n            locale: dateFnsLocale,\n          },\n        );\n\n        if (isValidDate(date)) {\n          words = words.slice(wordOffset);\n\n          log.debug('matched \"%s\" input using \"%s\" format (%s direction)', subject, format.dateFnsFormat, format.direction || 'no');\n\n          matches.push({\n            date: formatDate(date, 'yyyy-MM-dd'),\n          });\n        }\n      } else {\n        const yearIsExplicit = typeof format.yearIsExplicit === 'boolean' ? format.yearIsExplicit : true;\n\n        if (yearIsExplicit) {\n          const date = parseDate(\n            subject,\n            format.dateFnsFormat,\n            baseDate,\n            {\n              locale: dateFnsLocale,\n            },\n          );\n\n          if (!isValidDate(date)) {\n            continue;\n          }\n\n          const formatDirection = format.direction;\n          const configurationDirection = configuration.direction;\n\n          if (formatDirection && configurationDirection && format.dateFnsFormat.includes('yyyy') && formatDirection.replace('Y', '') === configurationDirection.replace('Y', '')) {\n            log.debug('matched format using yyyy; month-day direction matches');\n          } else if (format.direction && format.direction !== configuration.direction) {\n            log.trace('discarding match; direction mismatch');\n\n            continue;\n          }\n\n          if (format.direction && !configuration.direction) {\n            log.info('found a match using \"%s\" format; unsafe to use without `direction` configuration', format.dateFnsFormat);\n\n            continue;\n          }\n\n          words = words.slice(wordOffset);\n\n          log.debug('matched \"%s\" input using \"%s\" format (%s direction)', subject, format.dateFnsFormat, format.direction || 'no');\n\n          matches.push({\n            date: formatDate(date, 'yyyy-MM-dd'),\n          });\n        } else {\n          const date = parseDate(\n            subject,\n            format.dateFnsFormat,\n            baseDate,\n            {\n              locale: dateFnsLocale,\n            },\n          );\n\n          if (!isValidDate(date)) {\n            continue;\n          }\n\n          const currentYear = parseInt(formatDate(baseDate, 'yyyy'), 10);\n\n          const currentMonth = parseInt(formatDate(baseDate, 'M'), 10) + currentYear * 12;\n          const parsedMonth = parseInt(formatDate(date, 'M'), 10) + parseInt(formatDate(date, 'yyyy'), 10) * 12;\n          const difference = parsedMonth - currentMonth;\n\n          let useYear;\n\n          if (difference >= configuration.maximumAge) {\n            useYear = currentYear - 1;\n          } else if (difference < 0 && Math.abs(difference) >= configuration.minimumAge) {\n            useYear = currentYear + 1;\n          } else {\n            useYear = currentYear;\n          }\n\n          const maybeDate = parseDate(\n            useYear + '-' + formatDate(date, 'MM-dd'),\n            'yyyy-MM-dd',\n            baseDate,\n            {\n              locale: dateFnsLocale,\n            },\n          );\n\n          if (!isValidDate(maybeDate)) {\n            continue;\n          }\n\n          if (format.direction && format.direction !== configuration.direction) {\n            log.trace('discarding match; direction mismatch');\n\n            continue;\n          }\n\n          if (format.direction && !configuration.direction) {\n            log.info('found a match using \"%s\" format; unsafe to use without \"format\" configuration', format.dateFnsFormat);\n\n            continue;\n          }\n\n          words = words.slice(wordOffset);\n\n          log.debug('matched \"%s\" input using \"%s\" format (%s direction)', subject, format.dateFnsFormat, format.direction || 'no');\n\n          matches.push({\n            date: formatDate(maybeDate, 'yyyy-MM-dd'),\n          });\n        }\n      }\n    }\n  }\n\n  return matches;\n};\n"],"file":"extractDate.js"}