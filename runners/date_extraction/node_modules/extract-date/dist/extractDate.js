"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _dateFns = require("date-fns");

var locales = _interopRequireWildcard(require("date-fns/locale"));

var _momentTimezone = _interopRequireDefault(require("moment-timezone"));

var _relativeDateNames = _interopRequireDefault(require("relative-date-names"));

var _createMovingChunks = _interopRequireDefault(require("./createMovingChunks"));

var _extractRelativeDate = _interopRequireDefault(require("./extractRelativeDate"));

var _createFormats = _interopRequireDefault(require("./createFormats"));

var _normalizeInput = _interopRequireDefault(require("./normalizeInput"));

var _Logger = _interopRequireDefault(require("./Logger"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/* eslint-disable no-continue, no-negated-condition, import/no-namespace */
const log = _Logger.default.child({
  namespace: 'extractDate'
});

const defaultConfiguration = {
  maximumAge: Infinity,
  minimumAge: Infinity
};
const formats = (0, _createFormats.default)();
const dateFnsLocaleMap = {
  en: 'enUS'
}; // eslint-disable-next-line complexity

var _default = (input, userConfiguration = defaultConfiguration) => {
  log.debug('attempting to extract date from "%s" input', input);
  const normalizedInput = (0, _normalizeInput.default)(input);
  log.debug('normalized input to "%s"', normalizedInput);
  const configuration = { ...defaultConfiguration,
    ...userConfiguration
  };
  const locale = configuration.locale || 'en';
  const dateFnsLocale = locales[dateFnsLocaleMap[locale] || locale];

  if (!dateFnsLocale) {
    throw new Error('No translation available for the target locale (date-fns).');
  }

  if (!_relativeDateNames.default[locale]) {
    throw new Error('No translation available for the target locale (relative dates).');
  }

  if (configuration.timezone && !_momentTimezone.default.tz.zone(configuration.timezone)) {
    throw new Error('Unrecognized timezone.');
  }

  if (configuration.maximumAge && configuration.maximumAge < 0) {
    throw new Error('`maximumAge` must be a positive number.');
  }

  if (configuration.minimumAge && configuration.minimumAge < 0) {
    throw new Error('`minimumAge` must be a positive number.');
  }

  log.debug({
    configuration
  }, 'attempting to extract date from "%s" input', normalizedInput);
  let words = normalizedInput.split(' ');
  const matches = [];
  const baseDate = (0, _dateFns.parse)('12:00', 'HH:mm', new Date());

  for (const format of formats) {
    const movingChunks = (0, _createMovingChunks.default)(words, format.wordCount);
    let chunkIndex = 0;

    for (const movingChunk of movingChunks) {
      const wordOffset = ++chunkIndex * format.wordCount;
      const subject = movingChunk.join(' ');

      if (format.dateFnsFormat === 'R') {
        if (!configuration.locale) {
          log.trace('cannot attempt format without `locale` configuration');
        } else if (!configuration.timezone) {
          log.trace('cannot attempt format without `timezone` configuration');
        } else {
          const maybeDate = (0, _extractRelativeDate.default)(subject, configuration.locale, configuration.timezone);

          if (maybeDate) {
            words = words.slice(wordOffset);
            log.debug('matched "%s" input using "%s" format (%s direction)', subject, format.dateFnsFormat, format.direction || 'no');
            matches.push({
              date: maybeDate
            });
          }
        }
      } else if (format.dateFnsFormat === 'EEE' || format.dateFnsFormat === 'EEEE') {
        const date = (0, _dateFns.parse)(subject, format.dateFnsFormat, baseDate, {
          locale: dateFnsLocale
        });

        if ((0, _dateFns.isValid)(date)) {
          words = words.slice(wordOffset);
          log.debug('matched "%s" input using "%s" format (%s direction)', subject, format.dateFnsFormat, format.direction || 'no');
          matches.push({
            date: (0, _dateFns.format)(date, 'yyyy-MM-dd')
          });
        }
      } else {
        const yearIsExplicit = typeof format.yearIsExplicit === 'boolean' ? format.yearIsExplicit : true;

        if (yearIsExplicit) {
          const date = (0, _dateFns.parse)(subject, format.dateFnsFormat, baseDate, {
            locale: dateFnsLocale
          });

          if (!(0, _dateFns.isValid)(date)) {
            continue;
          }

          const formatDirection = format.direction;
          const configurationDirection = configuration.direction;

          if (formatDirection && configurationDirection && format.dateFnsFormat.includes('yyyy') && formatDirection.replace('Y', '') === configurationDirection.replace('Y', '')) {
            log.debug('matched format using yyyy; month-day direction matches');
          } else if (format.direction && format.direction !== configuration.direction) {
            log.trace('discarding match; direction mismatch');
            continue;
          }

          if (format.direction && !configuration.direction) {
            log.info('found a match using "%s" format; unsafe to use without `direction` configuration', format.dateFnsFormat);
            continue;
          }

          words = words.slice(wordOffset);
          log.debug('matched "%s" input using "%s" format (%s direction)', subject, format.dateFnsFormat, format.direction || 'no');
          matches.push({
            date: (0, _dateFns.format)(date, 'yyyy-MM-dd')
          });
        } else {
          const date = (0, _dateFns.parse)(subject, format.dateFnsFormat, baseDate, {
            locale: dateFnsLocale
          });

          if (!(0, _dateFns.isValid)(date)) {
            continue;
          }

          const currentYear = parseInt((0, _dateFns.format)(baseDate, 'yyyy'), 10);
          const currentMonth = parseInt((0, _dateFns.format)(baseDate, 'M'), 10) + currentYear * 12;
          const parsedMonth = parseInt((0, _dateFns.format)(date, 'M'), 10) + parseInt((0, _dateFns.format)(date, 'yyyy'), 10) * 12;
          const difference = parsedMonth - currentMonth;
          let useYear;

          if (difference >= configuration.maximumAge) {
            useYear = currentYear - 1;
          } else if (difference < 0 && Math.abs(difference) >= configuration.minimumAge) {
            useYear = currentYear + 1;
          } else {
            useYear = currentYear;
          }

          const maybeDate = (0, _dateFns.parse)(useYear + '-' + (0, _dateFns.format)(date, 'MM-dd'), 'yyyy-MM-dd', baseDate, {
            locale: dateFnsLocale
          });

          if (!(0, _dateFns.isValid)(maybeDate)) {
            continue;
          }

          if (format.direction && format.direction !== configuration.direction) {
            log.trace('discarding match; direction mismatch');
            continue;
          }

          if (format.direction && !configuration.direction) {
            log.info('found a match using "%s" format; unsafe to use without "format" configuration', format.dateFnsFormat);
            continue;
          }

          words = words.slice(wordOffset);
          log.debug('matched "%s" input using "%s" format (%s direction)', subject, format.dateFnsFormat, format.direction || 'no');
          matches.push({
            date: (0, _dateFns.format)(maybeDate, 'yyyy-MM-dd')
          });
        }
      }
    }
  }

  return matches;
};

exports.default = _default;
//# sourceMappingURL=extractDate.js.map